#!/usr/bin/python3
#
# This is a simple script used to implement a shell singleton. It is useful
# when you want to run a program if and only if the program isn't currently
# running.  An example is autostarted programs in desktop environments. If you
# configure a program to run whenever your DE starts and it doesn't depend on
# the GUI, then if you logout and login again you will now have two instances
# of that program running. By wrapping the program invocation with this script,
# that issue won't happen.
#
# Copyright 2015 Martin Kelly <martin@martingkelly.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import errno
import fcntl
import os
import subprocess
import sys


def get_lockdir():
    '''Determines and returns the directory to use for the lockfile.'''

    if os.path.isdir('/var/lock'):
        return '/var/lock'
    if os.path.isdir('/tmp'):
        return '/tmp'
    return '.'


def parse_options():
    program_name = sys.argv[0]
    description = \
'''%s is a simple script used
to implement a shell singleton. By wrapping a command invocation with %s,
the program is guaranteed to be the only one among others wrapped with %s.''' \
% (program_name, program_name, program_name)

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('-l', '--lockfile',
                        default=None,
                        help='The lockfile to use for the invocation')
    parser.add_argument('cmd',
                        nargs=argparse.REMAINDER,
                        help='The actual command to run')

    return parser.parse_args()


def main():
    '''Main'''

    args = parse_options()
    if not args.cmd:
        sys.exit(0)

    if args.lockfile is None:
        lockdir = get_lockdir()
        lockfile = '%s/%s-lock-%s' % (lockdir, sys.argv[0], args.cmd[0])
    else:
        lockfile = args.lockfile

    with open(lockfile, 'w') as f:
        # Grab lock.
        try:
            fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError as e:
            if not e.errno in (errno.EACCES, errno.EAGAIN):
                raise e
            sys.exit(1)

        # Run the command.
        status = subprocess.call(args.cmd)

        # Cleanup. It's important that we remove the file before closing it, as
        # closing it drops the lock. If we close the file first, it's possible
        # someone else grabs the lock, which we then remove. Since doing a lockf
        # on a nonexistent file always succeeds, this would be bad.
        os.remove(lockfile)
        fcntl.lockf(f, fcntl.LOCK_UN)

    # Exit with the child command's status.
    sys.exit(status)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
