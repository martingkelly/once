#!/bin/sh
#
# This is a simple script used to implement a shell singleton. It is useful
# when you want to run a program if and only if the program isn't currently
# running.  An example is autostarted programs in desktop environments. If you
# configure a program to run whenever your DE starts and it doesn't depend on
# the GUI, then if you logout and login again you will now have two instances
# of that program running. By wrapping the program invocation with this script,
# that issue won't happen.
#
# Copyright 2015 Martin Kelly <martin@martingkelly.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

set -e

usage() {
    cat <<EOF
once is a simple script used to implement a shell singleton. By wrapping a
command invocation with once, the program is guaranteed to be the only one
among others wrapped with once.

Usage: once COMMAND
       once [-l|--lockfile] LOCKFILE COMMAND
EOF
}

if [ "$1" = -h ] || [ "$1" = --help ]; then
    usage
    exit
fi

if [ "$1" = -l ] || [ "$1" = --lockfile ]; then
    LOCKFILE="$2"
    shift 2
else
    PROGRAM="$(basename "$1")"
    LOCKFILE="/var/lock/once-lock-$PROGRAM"
fi

# Take the lock.
exec 3>"$LOCKFILE"
if ! flock --exclusive --nonblock 3; then
    exit 1
fi

# Execute the command and wait for it to finish.
"$@"
STATUS=$?

# Cleanup. It's important that we remove the file before closing it, as
# closing it drops the lock. If we close the file first, it's possible someone
# else grabs the lock, which we then remove. Since doing an flock on a
# nonexistent file always succeeds, this would be bad.
rm "$LOCKFILE"
exec 3>&-

# Exit with the command's status.
exit $STATUS
